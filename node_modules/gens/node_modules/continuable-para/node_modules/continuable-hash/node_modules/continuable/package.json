{
  "name": "continuable",
  "version": "1.1.8",
  "description": "Idea for callbacks as values",
  "keywords": [],
  "author": {
    "name": "Raynos",
    "email": "raynos2@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Raynos/continuable.git"
  },
  "main": "index",
  "homepage": "https://github.com/Raynos/continuable",
  "contributors": [
    {
      "name": "Raynos"
    }
  ],
  "bugs": {
    "url": "https://github.com/Raynos/continuable/issues",
    "email": "raynos2@gmail.com"
  },
  "dependencies": {},
  "devDependencies": {
    "tape": "~1.0.2"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/Raynos/continuable/raw/master/LICENSE"
    }
  ],
  "scripts": {
    "test": "node ./test/index.js"
  },
  "testling": {
    "files": "test/index.js",
    "browsers": [
      "ie/8..latest",
      "firefox/16..latest",
      "firefox/nightly",
      "chrome/22..latest",
      "chrome/canary",
      "opera/12..latest",
      "opera/next",
      "safari/5.1..latest",
      "ipad/6.0..latest",
      "iphone/6.0..latest"
    ]
  },
  "readme": "# continuable\n\n[![build status][1]][2] [![dependency status][3]][4]\n\n[![browser support][5]][6]\n\nIdea for callbacks as values\n\n## Example\n\n```js\nvar readFile = function (uri) {\n    return function (cb) {\n        fs.readFile(uri, cb)\n    }\n}\n\nfunction map(source, lambda) {\n    return function continuable(callback) {\n        source(function (err, value) {\n            callback(err, err ? null : lambda(value))\n        })\n    }\n}\n\nvar asString = map(readFile(\"/tmp/foo.json\"), String)\nvar asJSON = map(asString, function (x) { return JSON.parse(x) })\n\nasJSON(function (err, value) {\n    /* do stuff with JSON */\n})\n```\n\n## Docs\n\n### `Continuable(callback)`\n\n```js\ntype Continuable := (callback:(Error, Value) => void) => void\n```\n\nA continuable is simply a function that takes a single argument, a callback.\nThe callback get's called with the normal node error and value pattern.\n\n```js\n// readFile := (String) => Continuable<Buffer>\nvar readFile = function (uri) {\n    return function continuable(callback) {\n        fs.readFile(uri, callback)\n    }\n}\n```\n\nThe reason to have a continuable instead of passing a callback directly into\nanother value is that a continuable is a concrete value that can be returned.\n\nWhich means you can call useful functions on this value like `map` and `join`\n\n### `to(asyncFunction)`\n\ntake an async function and return a function that works as async function or continuable.\n\n``` js\nvar readFile = continuable.to(fs.readFile)\n\nreadFile (path, 'utf8') (function (err, text) {\n  //there you go\n})\n```\n\n### `map(source, lambda)`\n\n```js\nmap := (source:Continuable<A>, lambda:(A) => B) => Continuable<B>\n```\n\nmap takes a transformation function and a continuable and returns a new\ncontinuable. The new continuable is the value of the first continuable\ntransformed by your mapping function.\n\n```js\nvar asString = map(readFile(\"/tmp/foo.json\"), String)\nvar asJSON = map(asString, function (x) { return JSON.parse(x) })\n\nasJSON(function (err, json) {\n    /* do stuff */\n})\n```\n\n### `mapAsync(source, lambda)`\n\n```ocaml\nmapAsync := (source: Continuable<A>, lambda: (A, Callback<B>))\n    => Continuable<B>\n```\n\nmapAsync takes an asynchronous transformation function and a source\ncontinuable. The new continuable is the value of the first continuable\npassed through the async transformation.\n\n```js\nvar asString = map(readFile(\"/tmp/foo.json\"), String)\nvar asJSON = map(asString, function (x) { return JSON.parse(x) })\n\nvar written = mapAsync(asJSON, function (json, cb) {\n    fs.writeFile(\"/tmp/bar.json\", JSON.stringify(json), cb)\n})\n\nwritten(function (err, writeResult) {\n    /* stuff */\n})\n```\n\n### `join(continuable)`\n\n```js\njoin := (source:Continuable<Continuable<T>>) => Continuable<T>\n```\n\n`join` takes a continuable that contains another continuable and flattens it by\none layer. This is useful if you return another asynchronous operation from\n`map`\n\n```js\nvar asString = map(readFile(\"/tmp/foo.json\"), String)\nvar asJSON = map(asString, function (x) { return JSON.parse(x) })\n\nvar write = map(asJSON, function (json) {\n    return function continuable(cb) {\n        fs.writeFile(\"/tmp/bar.json\", JSON.stringify(json), cb)\n    }\n})\n\njoin(write)(function (err, writeResult) {\n    /* stuff */\n})\n```\n\n### `both(source)`\n\n```ocaml\ncontinuable := (Continuable<A>) => Continuable<[Error, A]>\n```\n\n`both` takes a continuable and returns a continuable containing a tuple of\n    the error and the value. The returned continuable will never contain an\n    error.\n\nThis is useful for handling errors using if statements\n\n```js\nvar fileOrNull = function (uri) {\n    var source = fs.readFile.bind(null, uri)\n    var maybeFile = both(source)\n\n    return map(maybeFile, function (err, tuple) {\n        if (tuple[0]) {\n            return null\n        }\n\n        return tuple[1]\n    })\n}\n```\n\n### `of(value)`\n\n```js\nof := (Value) => Continuable<Value>\n```\n\n`of` takes any value and returns a Continuable for this value. This is useful\n    if you want to implement a function that either returns a value or a\n    continuable.\n\n```js\nfunction getThing() {\n    var thing = localStorage.getItem(\"thing\")\n\n    if (thing) return of(thing)\n\n    return ajax(\"/thing\")\n}\n```\n\n### `error(err)`\n\n```js\nerror := (Error) => Continuable<void>\n```\n\n`error` takes any error and returns a Continuable that will return said error.\n    This is useful if you want to transform a normal continuable into an\n    error state one.\n\n```js\nvar body = getBody(req, res)\n\nvar dbWrite = map(body, function (body) {\n    if (!body) {\n        return error(new Error(\"Need body\"))\n    }\n\n    return db.write(body)\n})\n\njoin(dbWrite)(function (err, writeResult) {\n    /* do stuff */\n})\n```\n\n### `chain(continuable, lambda)`\n\n```js\nchain := (Continuable<A>, (A) => Continuable<B>) => Continuable<B>\n```\n\n`chain` takes a lambda function that is given the value and returns another\n    continuables. The result will be a continuable given the value of the\n    returned continuable.\n\nIn combination with `of` this makes `Continuable` a monad.\n\nAlternatively this can be seen as sugar for `map` followed by `join`\n\n```js\nvar body = getBody(req, res)\n\nvar dbWrite = chain(body, function (body) {\n    if (!body) {\n        return error(new Error(\"Need body\"))\n    }\n\n    return db.write(body)\n})\n\ndbWrite(function (err, writeResult) {\n    /* do stuff */\n})\n```\n\n### `either(continuable, left, right?)`\n\n```js\neither := (source: Continuable<A>,\n           left: (Error, cb: Callback<B>) => Continuable<B>,\n          right?: (A) => Continuable<B>)\n    => Continuable<B>\n```\n\n`either` takes a source continuable and a left and right function.\n    It will either call the left function with the error in source\n    or call the right function with the value in the source.\n\nThe returned continuable will contain the value returned from\n    either left or right. Note that left and right return\n    continuables themself.\n\n```js\nvar fs = require(\"fs\")\nvar either = require(\"continuable/either\")\n\nvar fileStat = fs.stat.bind(null, \"./package.json\")\nvar fileExists = either(fileStat, function left(err) {\n    return fs.writeFile.bind(null, \"./package.json\", \"{}\")\n}) // note the right function is optional\n\nvar file = chain(fileExists, function () {\n    return fs.readFile.bind(null, \"./package.json\")\n})\n\nfile(function (err, body) {\n    // There is no error because we create an empty file if the\n    // stat failed. Body is either body or {}\n})\n```\n\nThe left function can either return a Continuable or call the\n    passed callback directly. For example:\n\n```js\nvar item = fs.stat.bind(null, \"./file\")\nvar maybeItem = either(item, function left(err, cb) {\n    if (err.code === \"ENOENT\") {\n        return cb(null, null)\n    }\n\n    cb(err)\n})\n\nmaybeItem(function (err, item) {\n    // if stat returns a file not found then item is null\n    // if stat returns a random disk error then error!\n    // if stat returns the stat then item!\n})\n```\n\nUsing the callback form is convenient and avoids the usage of\n    return `return of(null)` and `return error(err)`\n\n## `series([continuables])`\n\nSee [continuable-series][7]\n\nGiven an array of continuables return a continuable that invokes them in order,\nor until one errors.\n\n## `para([continuables])`\n\nSee [continuable-para][8]\n\nGiven an array on continuables return a continuable\n\n## Installation\n\n`npm install continuable`\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n\n  [1]: https://secure.travis-ci.org/Raynos/continuable.png\n  [2]: https://travis-ci.org/Raynos/continuable\n  [3]: https://david-dm.org/Raynos/continuable.png\n  [4]: https://david-dm.org/Raynos/continuable\n  [5]: https://ci.testling.com/Raynos/continuable.png\n  [6]: https://ci.testling.com/Raynos/continuable\n  [7]: http://ghub.io/continuable-series\n  [8]: http://ghub.io/continuable-para\n",
  "readmeFilename": "README.md",
  "_id": "continuable@1.1.8",
  "_shasum": "dc877b474160870ae3bcde87336268ebe50597d5",
  "_from": "continuable@>=1.1.6 <1.2.0",
  "_resolved": "https://registry.npmjs.org/continuable/-/continuable-1.1.8.tgz"
}
